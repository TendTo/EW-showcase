/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import { ContractOptions } from "web3-eth-contract";
import { EventLog } from "web3-core";
import { EventEmitter } from "events";
import {
  Callback,
  PayableTransactionObject,
  NonPayableTransactionObject,
  BlockType,
  ContractEventLog,
  BaseContract,
} from "./types";

interface EventOptions {
  filter?: object;
  fromBlock?: BlockType;
  topics?: string[];
}

export type DemandCancelled = ContractEventLog<{
  buyer: string;
  0: string;
}>;
export type DemandCreated = ContractEventLog<{
  buyer: string;
  volume: string;
  price: string;
  0: string;
  1: string;
  2: string;
}>;
export type MatchAccepted = ContractEventLog<{
  matchId: string;
  0: string;
}>;
export type MatchCancelled = ContractEventLog<{
  matchId: string;
  0: string;
}>;
export type MatchDeleted = ContractEventLog<{
  matchId: string;
  0: string;
}>;
export type MatchProposed = ContractEventLog<{
  matchId: string;
  asset: string;
  buyer: string;
  0: string;
  1: string;
  2: string;
}>;
export type MatchRejected = ContractEventLog<{
  matchId: string;
  0: string;
}>;
export type OfferCancelled = ContractEventLog<{
  asset: string;
  0: string;
}>;
export type OfferCreated = ContractEventLog<{
  asset: string;
  volume: string;
  price: string;
  0: string;
  1: string;
  2: string;
}>;

export interface MarketplaceAbi extends BaseContract {
  constructor(
    jsonInterface: any[],
    address?: string,
    options?: ContractOptions
  ): MarketplaceAbi;
  clone(): MarketplaceAbi;
  methods: {
    demands(arg0: string): NonPayableTransactionObject<{
      isMatched: boolean;
      volume: string;
      price: string;
      0: boolean;
      1: string;
      2: string;
    }>;

    matches(arg0: number | string | BN): NonPayableTransactionObject<{
      asset: string;
      buyer: string;
      volume: string;
      price: string;
      isAccepted: boolean;
      0: string;
      1: string;
      2: string;
      3: string;
      4: boolean;
    }>;

    offers(arg0: string): NonPayableTransactionObject<{
      matches: string;
      volume: string;
      remainingVolume: string;
      price: string;
      0: string;
      1: string;
      2: string;
      3: string;
    }>;

    /**
     * The address that submits the offer must be the owner of the assetThe volume must be greater than 0The price must be greater than 0The offed must not be already matched, for it will be overwritten
     * Create a new offer linked to a specific asset
     * @param _asset address (DID) of the asset
     * @param _price price of the energy provided in ct/KWh
     * @param _volume volume of the asset in KW
     */
    createOffer(
      _asset: string,
      _volume: number | string | BN,
      _price: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * The address that cancels the offer must be the owner of the assetThe offer must existThe offer must not be matched
     * Cancels a previously issued offer. Can only be performed if the offer is not matched
     * @param _asset address (DID) of the asset
     */
    cancelOffer(_asset: string): NonPayableTransactionObject<void>;

    /**
     * The volume must be greater than 0The price must be greater than 0The demand must not be already matched, for it will be overwritten
     * Create a new demand
     * @param _price price of the energy provided in ct/KWh
     * @param _volume volume of the asset in KW
     */
    createDemand(
      _volume: number | string | BN,
      _price: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * The demand must existThe demand must not be matched
     * Cancels a previously issued demand
     */
    cancelDemand(): NonPayableTransactionObject<void>;

    /**
     * The demand must existThe demand must not be matchedThe offer must existThe offer must not be matchedThe volume of the demand must be greater than the volume of the offerThe price of the demand must be greater than the price of the offer todo Stronger check to make sure the offer volume is respected from multiple matches
     * Propose a match between an offer and a demand
     * @param _asset address (DID) of the asset
     * @param _buyer address of the buyer
     */
    proposeMatch(
      _asset: string,
      _buyer: string,
      _volume: number | string | BN,
      _price: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Only the aggregator can perform this operationThe match must exist
     * Cancel a previously proposed match
     * @param _matchId id of the match to cancel
     */
    cancelProposedMatch(
      _matchId: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Only the buyer can perform this operationThe match must exist
     * Accept a previously proposed match
     * @param _matchId id of the match to accept
     */
    acceptMatch(
      _matchId: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Only the buyer can perform this operationThe match must exist
     * Reject a previously proposed match
     * @param _matchId id of the match to reject
     */
    rejectMatch(
      _matchId: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Both the buyer and the asset owner can perform this operationThe match must exist and be accepted
     * Delete a previously accepted match
     * @param _matchId id of the match to delete
     */
    deleteMatch(
      _matchId: number | string | BN
    ): NonPayableTransactionObject<void>;
  };
  events: {
    DemandCancelled(cb?: Callback<DemandCancelled>): EventEmitter;
    DemandCancelled(
      options?: EventOptions,
      cb?: Callback<DemandCancelled>
    ): EventEmitter;

    DemandCreated(cb?: Callback<DemandCreated>): EventEmitter;
    DemandCreated(
      options?: EventOptions,
      cb?: Callback<DemandCreated>
    ): EventEmitter;

    MatchAccepted(cb?: Callback<MatchAccepted>): EventEmitter;
    MatchAccepted(
      options?: EventOptions,
      cb?: Callback<MatchAccepted>
    ): EventEmitter;

    MatchCancelled(cb?: Callback<MatchCancelled>): EventEmitter;
    MatchCancelled(
      options?: EventOptions,
      cb?: Callback<MatchCancelled>
    ): EventEmitter;

    MatchDeleted(cb?: Callback<MatchDeleted>): EventEmitter;
    MatchDeleted(
      options?: EventOptions,
      cb?: Callback<MatchDeleted>
    ): EventEmitter;

    MatchProposed(cb?: Callback<MatchProposed>): EventEmitter;
    MatchProposed(
      options?: EventOptions,
      cb?: Callback<MatchProposed>
    ): EventEmitter;

    MatchRejected(cb?: Callback<MatchRejected>): EventEmitter;
    MatchRejected(
      options?: EventOptions,
      cb?: Callback<MatchRejected>
    ): EventEmitter;

    OfferCancelled(cb?: Callback<OfferCancelled>): EventEmitter;
    OfferCancelled(
      options?: EventOptions,
      cb?: Callback<OfferCancelled>
    ): EventEmitter;

    OfferCreated(cb?: Callback<OfferCreated>): EventEmitter;
    OfferCreated(
      options?: EventOptions,
      cb?: Callback<OfferCreated>
    ): EventEmitter;

    allEvents(options?: EventOptions, cb?: Callback<EventLog>): EventEmitter;
  };

  once(event: "DemandCancelled", cb: Callback<DemandCancelled>): void;
  once(
    event: "DemandCancelled",
    options: EventOptions,
    cb: Callback<DemandCancelled>
  ): void;

  once(event: "DemandCreated", cb: Callback<DemandCreated>): void;
  once(
    event: "DemandCreated",
    options: EventOptions,
    cb: Callback<DemandCreated>
  ): void;

  once(event: "MatchAccepted", cb: Callback<MatchAccepted>): void;
  once(
    event: "MatchAccepted",
    options: EventOptions,
    cb: Callback<MatchAccepted>
  ): void;

  once(event: "MatchCancelled", cb: Callback<MatchCancelled>): void;
  once(
    event: "MatchCancelled",
    options: EventOptions,
    cb: Callback<MatchCancelled>
  ): void;

  once(event: "MatchDeleted", cb: Callback<MatchDeleted>): void;
  once(
    event: "MatchDeleted",
    options: EventOptions,
    cb: Callback<MatchDeleted>
  ): void;

  once(event: "MatchProposed", cb: Callback<MatchProposed>): void;
  once(
    event: "MatchProposed",
    options: EventOptions,
    cb: Callback<MatchProposed>
  ): void;

  once(event: "MatchRejected", cb: Callback<MatchRejected>): void;
  once(
    event: "MatchRejected",
    options: EventOptions,
    cb: Callback<MatchRejected>
  ): void;

  once(event: "OfferCancelled", cb: Callback<OfferCancelled>): void;
  once(
    event: "OfferCancelled",
    options: EventOptions,
    cb: Callback<OfferCancelled>
  ): void;

  once(event: "OfferCreated", cb: Callback<OfferCreated>): void;
  once(
    event: "OfferCreated",
    options: EventOptions,
    cb: Callback<OfferCreated>
  ): void;
}

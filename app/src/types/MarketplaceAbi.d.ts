/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface MarketplaceAbiInterface extends ethers.utils.Interface {
  functions: {
    "demands(address)": FunctionFragment;
    "matches(uint256)": FunctionFragment;
    "offers(address)": FunctionFragment;
    "createOffer(address,uint256,uint256)": FunctionFragment;
    "cancelOffer(address)": FunctionFragment;
    "createDemand(uint256,uint256)": FunctionFragment;
    "cancelDemand()": FunctionFragment;
    "proposeMatch(address,address,uint256,uint256)": FunctionFragment;
    "cancelProposedMatch(uint256)": FunctionFragment;
    "acceptMatch(uint256)": FunctionFragment;
    "rejectMatch(uint256)": FunctionFragment;
    "deleteMatch(uint256)": FunctionFragment;
  };

  encodeFunctionData(functionFragment: "demands", values: [string]): string;
  encodeFunctionData(
    functionFragment: "matches",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "offers", values: [string]): string;
  encodeFunctionData(
    functionFragment: "createOffer",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "cancelOffer", values: [string]): string;
  encodeFunctionData(
    functionFragment: "createDemand",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelDemand",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proposeMatch",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelProposedMatch",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "acceptMatch",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "rejectMatch",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deleteMatch",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "demands", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "matches", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "offers", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createOffer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOffer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createDemand",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelDemand",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposeMatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelProposedMatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "acceptMatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rejectMatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deleteMatch",
    data: BytesLike
  ): Result;

  events: {
    "DemandCancelled(address)": EventFragment;
    "DemandCreated(address,uint256,uint256)": EventFragment;
    "MatchAccepted(uint256)": EventFragment;
    "MatchCancelled(uint256)": EventFragment;
    "MatchDeleted(uint256)": EventFragment;
    "MatchProposed(uint256,address,address)": EventFragment;
    "MatchRejected(uint256)": EventFragment;
    "OfferCancelled(address)": EventFragment;
    "OfferCreated(address,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "DemandCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DemandCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MatchAccepted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MatchCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MatchDeleted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MatchProposed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MatchRejected"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OfferCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OfferCreated"): EventFragment;
}

export type DemandCancelledEvent = TypedEvent<[string] & { buyer: string }>;

export type DemandCreatedEvent = TypedEvent<
  [string, BigNumber, BigNumber] & {
    buyer: string;
    volume: BigNumber;
    price: BigNumber;
  }
>;

export type MatchAcceptedEvent = TypedEvent<
  [BigNumber] & { matchId: BigNumber }
>;

export type MatchCancelledEvent = TypedEvent<
  [BigNumber] & { matchId: BigNumber }
>;

export type MatchDeletedEvent = TypedEvent<
  [BigNumber] & { matchId: BigNumber }
>;

export type MatchProposedEvent = TypedEvent<
  [BigNumber, string, string] & {
    matchId: BigNumber;
    asset: string;
    buyer: string;
  }
>;

export type MatchRejectedEvent = TypedEvent<
  [BigNumber] & { matchId: BigNumber }
>;

export type OfferCancelledEvent = TypedEvent<[string] & { asset: string }>;

export type OfferCreatedEvent = TypedEvent<
  [string, BigNumber, BigNumber] & {
    asset: string;
    volume: BigNumber;
    price: BigNumber;
  }
>;

export class MarketplaceAbi extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: MarketplaceAbiInterface;

  functions: {
    demands(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber, BigNumber] & {
        isMatched: boolean;
        volume: BigNumber;
        price: BigNumber;
      }
    >;

    matches(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, string, BigNumber, BigNumber, boolean] & {
        asset: string;
        buyer: string;
        volume: BigNumber;
        price: BigNumber;
        isAccepted: boolean;
      }
    >;

    offers(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        matches: BigNumber;
        volume: BigNumber;
        remainingVolume: BigNumber;
        price: BigNumber;
      }
    >;

    /**
     * The address that submits the offer must be the owner of the assetThe volume must be greater than 0The price must be greater than 0The offed must not be already matched, for it will be overwritten
     * Create a new offer linked to a specific asset
     * @param _asset address (DID) of the asset
     * @param _price price of the energy provided in ct/KWh
     * @param _volume volume of the asset in KW
     */
    createOffer(
      _asset: string,
      _volume: BigNumberish,
      _price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The address that cancels the offer must be the owner of the assetThe offer must existThe offer must not be matched
     * Cancels a previously issued offer. Can only be performed if the offer is not matched
     * @param _asset address (DID) of the asset
     */
    cancelOffer(
      _asset: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The volume must be greater than 0The price must be greater than 0The demand must not be already matched, for it will be overwritten
     * Create a new demand
     * @param _price price of the energy provided in ct/KWh
     * @param _volume volume of the asset in KW
     */
    createDemand(
      _volume: BigNumberish,
      _price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The demand must existThe demand must not be matched
     * Cancels a previously issued demand
     */
    cancelDemand(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The demand must existThe demand must not be matchedThe offer must existThe offer must not be matchedThe volume of the demand must be greater than the volume of the offerThe price of the demand must be greater than the price of the offer todo Stronger check to make sure the offer volume is respected from multiple matches
     * Propose a match between an offer and a demand
     * @param _asset address (DID) of the asset
     * @param _buyer address of the buyer
     */
    proposeMatch(
      _asset: string,
      _buyer: string,
      _volume: BigNumberish,
      _price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only the aggregator can perform this operationThe match must exist
     * Cancel a previously proposed match
     * @param _matchId id of the match to cancel
     */
    cancelProposedMatch(
      _matchId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only the buyer can perform this operationThe match must exist
     * Accept a previously proposed match
     * @param _matchId id of the match to accept
     */
    acceptMatch(
      _matchId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only the buyer can perform this operationThe match must exist
     * Reject a previously proposed match
     * @param _matchId id of the match to reject
     */
    rejectMatch(
      _matchId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Both the buyer and the asset owner can perform this operationThe match must exist and be accepted
     * Delete a previously accepted match
     * @param _matchId id of the match to delete
     */
    deleteMatch(
      _matchId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  demands(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<
    [boolean, BigNumber, BigNumber] & {
      isMatched: boolean;
      volume: BigNumber;
      price: BigNumber;
    }
  >;

  matches(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [string, string, BigNumber, BigNumber, boolean] & {
      asset: string;
      buyer: string;
      volume: BigNumber;
      price: BigNumber;
      isAccepted: boolean;
    }
  >;

  offers(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      matches: BigNumber;
      volume: BigNumber;
      remainingVolume: BigNumber;
      price: BigNumber;
    }
  >;

  /**
   * The address that submits the offer must be the owner of the assetThe volume must be greater than 0The price must be greater than 0The offed must not be already matched, for it will be overwritten
   * Create a new offer linked to a specific asset
   * @param _asset address (DID) of the asset
   * @param _price price of the energy provided in ct/KWh
   * @param _volume volume of the asset in KW
   */
  createOffer(
    _asset: string,
    _volume: BigNumberish,
    _price: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The address that cancels the offer must be the owner of the assetThe offer must existThe offer must not be matched
   * Cancels a previously issued offer. Can only be performed if the offer is not matched
   * @param _asset address (DID) of the asset
   */
  cancelOffer(
    _asset: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The volume must be greater than 0The price must be greater than 0The demand must not be already matched, for it will be overwritten
   * Create a new demand
   * @param _price price of the energy provided in ct/KWh
   * @param _volume volume of the asset in KW
   */
  createDemand(
    _volume: BigNumberish,
    _price: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The demand must existThe demand must not be matched
   * Cancels a previously issued demand
   */
  cancelDemand(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The demand must existThe demand must not be matchedThe offer must existThe offer must not be matchedThe volume of the demand must be greater than the volume of the offerThe price of the demand must be greater than the price of the offer todo Stronger check to make sure the offer volume is respected from multiple matches
   * Propose a match between an offer and a demand
   * @param _asset address (DID) of the asset
   * @param _buyer address of the buyer
   */
  proposeMatch(
    _asset: string,
    _buyer: string,
    _volume: BigNumberish,
    _price: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only the aggregator can perform this operationThe match must exist
   * Cancel a previously proposed match
   * @param _matchId id of the match to cancel
   */
  cancelProposedMatch(
    _matchId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only the buyer can perform this operationThe match must exist
   * Accept a previously proposed match
   * @param _matchId id of the match to accept
   */
  acceptMatch(
    _matchId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only the buyer can perform this operationThe match must exist
   * Reject a previously proposed match
   * @param _matchId id of the match to reject
   */
  rejectMatch(
    _matchId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Both the buyer and the asset owner can perform this operationThe match must exist and be accepted
   * Delete a previously accepted match
   * @param _matchId id of the match to delete
   */
  deleteMatch(
    _matchId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    demands(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber, BigNumber] & {
        isMatched: boolean;
        volume: BigNumber;
        price: BigNumber;
      }
    >;

    matches(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, string, BigNumber, BigNumber, boolean] & {
        asset: string;
        buyer: string;
        volume: BigNumber;
        price: BigNumber;
        isAccepted: boolean;
      }
    >;

    offers(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        matches: BigNumber;
        volume: BigNumber;
        remainingVolume: BigNumber;
        price: BigNumber;
      }
    >;

    /**
     * The address that submits the offer must be the owner of the assetThe volume must be greater than 0The price must be greater than 0The offed must not be already matched, for it will be overwritten
     * Create a new offer linked to a specific asset
     * @param _asset address (DID) of the asset
     * @param _price price of the energy provided in ct/KWh
     * @param _volume volume of the asset in KW
     */
    createOffer(
      _asset: string,
      _volume: BigNumberish,
      _price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The address that cancels the offer must be the owner of the assetThe offer must existThe offer must not be matched
     * Cancels a previously issued offer. Can only be performed if the offer is not matched
     * @param _asset address (DID) of the asset
     */
    cancelOffer(_asset: string, overrides?: CallOverrides): Promise<void>;

    /**
     * The volume must be greater than 0The price must be greater than 0The demand must not be already matched, for it will be overwritten
     * Create a new demand
     * @param _price price of the energy provided in ct/KWh
     * @param _volume volume of the asset in KW
     */
    createDemand(
      _volume: BigNumberish,
      _price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The demand must existThe demand must not be matched
     * Cancels a previously issued demand
     */
    cancelDemand(overrides?: CallOverrides): Promise<void>;

    /**
     * The demand must existThe demand must not be matchedThe offer must existThe offer must not be matchedThe volume of the demand must be greater than the volume of the offerThe price of the demand must be greater than the price of the offer todo Stronger check to make sure the offer volume is respected from multiple matches
     * Propose a match between an offer and a demand
     * @param _asset address (DID) of the asset
     * @param _buyer address of the buyer
     */
    proposeMatch(
      _asset: string,
      _buyer: string,
      _volume: BigNumberish,
      _price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only the aggregator can perform this operationThe match must exist
     * Cancel a previously proposed match
     * @param _matchId id of the match to cancel
     */
    cancelProposedMatch(
      _matchId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only the buyer can perform this operationThe match must exist
     * Accept a previously proposed match
     * @param _matchId id of the match to accept
     */
    acceptMatch(
      _matchId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only the buyer can perform this operationThe match must exist
     * Reject a previously proposed match
     * @param _matchId id of the match to reject
     */
    rejectMatch(
      _matchId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Both the buyer and the asset owner can perform this operationThe match must exist and be accepted
     * Delete a previously accepted match
     * @param _matchId id of the match to delete
     */
    deleteMatch(
      _matchId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "DemandCancelled(address)"(
      buyer?: string | null
    ): TypedEventFilter<[string], { buyer: string }>;

    DemandCancelled(
      buyer?: string | null
    ): TypedEventFilter<[string], { buyer: string }>;

    "DemandCreated(address,uint256,uint256)"(
      buyer?: string | null,
      volume?: null,
      price?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { buyer: string; volume: BigNumber; price: BigNumber }
    >;

    DemandCreated(
      buyer?: string | null,
      volume?: null,
      price?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { buyer: string; volume: BigNumber; price: BigNumber }
    >;

    "MatchAccepted(uint256)"(
      matchId?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { matchId: BigNumber }>;

    MatchAccepted(
      matchId?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { matchId: BigNumber }>;

    "MatchCancelled(uint256)"(
      matchId?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { matchId: BigNumber }>;

    MatchCancelled(
      matchId?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { matchId: BigNumber }>;

    "MatchDeleted(uint256)"(
      matchId?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { matchId: BigNumber }>;

    MatchDeleted(
      matchId?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { matchId: BigNumber }>;

    "MatchProposed(uint256,address,address)"(
      matchId?: BigNumberish | null,
      asset?: string | null,
      buyer?: string | null
    ): TypedEventFilter<
      [BigNumber, string, string],
      { matchId: BigNumber; asset: string; buyer: string }
    >;

    MatchProposed(
      matchId?: BigNumberish | null,
      asset?: string | null,
      buyer?: string | null
    ): TypedEventFilter<
      [BigNumber, string, string],
      { matchId: BigNumber; asset: string; buyer: string }
    >;

    "MatchRejected(uint256)"(
      matchId?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { matchId: BigNumber }>;

    MatchRejected(
      matchId?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { matchId: BigNumber }>;

    "OfferCancelled(address)"(
      asset?: string | null
    ): TypedEventFilter<[string], { asset: string }>;

    OfferCancelled(
      asset?: string | null
    ): TypedEventFilter<[string], { asset: string }>;

    "OfferCreated(address,uint256,uint256)"(
      asset?: string | null,
      volume?: null,
      price?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { asset: string; volume: BigNumber; price: BigNumber }
    >;

    OfferCreated(
      asset?: string | null,
      volume?: null,
      price?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { asset: string; volume: BigNumber; price: BigNumber }
    >;
  };

  estimateGas: {
    demands(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    matches(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    offers(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The address that submits the offer must be the owner of the assetThe volume must be greater than 0The price must be greater than 0The offed must not be already matched, for it will be overwritten
     * Create a new offer linked to a specific asset
     * @param _asset address (DID) of the asset
     * @param _price price of the energy provided in ct/KWh
     * @param _volume volume of the asset in KW
     */
    createOffer(
      _asset: string,
      _volume: BigNumberish,
      _price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The address that cancels the offer must be the owner of the assetThe offer must existThe offer must not be matched
     * Cancels a previously issued offer. Can only be performed if the offer is not matched
     * @param _asset address (DID) of the asset
     */
    cancelOffer(
      _asset: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The volume must be greater than 0The price must be greater than 0The demand must not be already matched, for it will be overwritten
     * Create a new demand
     * @param _price price of the energy provided in ct/KWh
     * @param _volume volume of the asset in KW
     */
    createDemand(
      _volume: BigNumberish,
      _price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The demand must existThe demand must not be matched
     * Cancels a previously issued demand
     */
    cancelDemand(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The demand must existThe demand must not be matchedThe offer must existThe offer must not be matchedThe volume of the demand must be greater than the volume of the offerThe price of the demand must be greater than the price of the offer todo Stronger check to make sure the offer volume is respected from multiple matches
     * Propose a match between an offer and a demand
     * @param _asset address (DID) of the asset
     * @param _buyer address of the buyer
     */
    proposeMatch(
      _asset: string,
      _buyer: string,
      _volume: BigNumberish,
      _price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Only the aggregator can perform this operationThe match must exist
     * Cancel a previously proposed match
     * @param _matchId id of the match to cancel
     */
    cancelProposedMatch(
      _matchId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Only the buyer can perform this operationThe match must exist
     * Accept a previously proposed match
     * @param _matchId id of the match to accept
     */
    acceptMatch(
      _matchId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Only the buyer can perform this operationThe match must exist
     * Reject a previously proposed match
     * @param _matchId id of the match to reject
     */
    rejectMatch(
      _matchId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Both the buyer and the asset owner can perform this operationThe match must exist and be accepted
     * Delete a previously accepted match
     * @param _matchId id of the match to delete
     */
    deleteMatch(
      _matchId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    demands(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    matches(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    offers(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The address that submits the offer must be the owner of the assetThe volume must be greater than 0The price must be greater than 0The offed must not be already matched, for it will be overwritten
     * Create a new offer linked to a specific asset
     * @param _asset address (DID) of the asset
     * @param _price price of the energy provided in ct/KWh
     * @param _volume volume of the asset in KW
     */
    createOffer(
      _asset: string,
      _volume: BigNumberish,
      _price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The address that cancels the offer must be the owner of the assetThe offer must existThe offer must not be matched
     * Cancels a previously issued offer. Can only be performed if the offer is not matched
     * @param _asset address (DID) of the asset
     */
    cancelOffer(
      _asset: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The volume must be greater than 0The price must be greater than 0The demand must not be already matched, for it will be overwritten
     * Create a new demand
     * @param _price price of the energy provided in ct/KWh
     * @param _volume volume of the asset in KW
     */
    createDemand(
      _volume: BigNumberish,
      _price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The demand must existThe demand must not be matched
     * Cancels a previously issued demand
     */
    cancelDemand(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The demand must existThe demand must not be matchedThe offer must existThe offer must not be matchedThe volume of the demand must be greater than the volume of the offerThe price of the demand must be greater than the price of the offer todo Stronger check to make sure the offer volume is respected from multiple matches
     * Propose a match between an offer and a demand
     * @param _asset address (DID) of the asset
     * @param _buyer address of the buyer
     */
    proposeMatch(
      _asset: string,
      _buyer: string,
      _volume: BigNumberish,
      _price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only the aggregator can perform this operationThe match must exist
     * Cancel a previously proposed match
     * @param _matchId id of the match to cancel
     */
    cancelProposedMatch(
      _matchId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only the buyer can perform this operationThe match must exist
     * Accept a previously proposed match
     * @param _matchId id of the match to accept
     */
    acceptMatch(
      _matchId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only the buyer can perform this operationThe match must exist
     * Reject a previously proposed match
     * @param _matchId id of the match to reject
     */
    rejectMatch(
      _matchId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Both the buyer and the asset owner can perform this operationThe match must exist and be accepted
     * Delete a previously accepted match
     * @param _matchId id of the match to delete
     */
    deleteMatch(
      _matchId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
